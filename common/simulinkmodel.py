#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Sep 10 17:14:32 2020 by generateDS.py version 2.35.24.
# Python 3.8.2 (default, Jul 16 2020, 14:00:26)  [GCC 9.3.0]
#
# Command line options:
#   ('-o', 'simulinkmodel.py')
#   ('--external-encoding', 'utf-8')
#
# Command line arguments:
#   ../SimulinkModel.xsd
#
# Command line:
#   /home/ms-kondo/.local/bin/generateDS -o "simulinkmodel.py" --external-encoding="utf-8" ../SimulinkModel.xsd
#
# Current working directory (os.getcwd()):
#   c_cpp
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class elementType(str, Enum):
    COMPONENTSET='componentset'
    MASTERCOMPONENT='mastercomponent'
    COMMONINSTRUCTIONSET='commoninstructionset'


class kindType(str, Enum):
    RTMEXTERN='rtm-extern'
    RTMPOINTER='rtm-pointer'
    RTMOBJECT='rtm-object'
    BSIGNAL='bsignal'
    BSTATE='bstate'
    PARAM='param'


class kindType5(str, Enum):
    INIT='init'
    TASK='task'
    UPDATE='update'


class modeType(str, Enum):
    EXTIN='extin'
    EXTOUT='extout'
    INPUT='input'
    OUTPUT='output'
    STATE='state'
    TRIGGER_STATE='trigger_state'
    INVARIANT_SIGNAL='invariant_signal'


class typeType(str, Enum):
    SHIM='shim'
    SHIMSCHEMA='shim-schema'
    CSOURCE='c-source'
    CHEADER='c-header'
    CDATA='c-data'
    XML='xml'
    AMALTHEA='amalthea'
    CLANGAST='clang-ast'
    OTHER='other'


class typeType1(str, Enum):
    TASK='task'
    UPDATE='update'
    INIT='init'
    STATE='state'
    INVARIANT_SIGNAL='invariant_signal'
    PARAM='param'
    CONST='const'
    FUNC='func'
    AUTOVARS='autovars'
    RTMACRO='rt-macro'
    RTTYPE='rt-type'
    RTCODE='rt-code'
    RTINIT='rt-init'
    COMMON='common'
    COMMONINIT='common-init'
    C_MACRO='c_macro'
    PREAMBLE='preamble'


class typeType2(str, Enum):
    TASK='task'
    UPDATE='update'
    INIT='init'


class typeType3(str, Enum):
    DATA='data'
    EVENT='event'
    PORT='port'
    INIT='init'


class typeType4(str, Enum):
    DECL='decl'
    DEFN='defn'


class blocks_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, file=None, shim_params=None, block=None, code=None, object=None, deftype=None, includes=None, function=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if file is None:
            self.file = []
        else:
            self.file = file
        self.file_nsprefix_ = None
        if shim_params is None:
            self.shim_params = []
        else:
            self.shim_params = shim_params
        self.shim_params_nsprefix_ = None
        if block is None:
            self.block = []
        else:
            self.block = block
        self.block_nsprefix_ = None
        if code is None:
            self.code = []
        else:
            self.code = code
        self.code_nsprefix_ = None
        if object is None:
            self.object = []
        else:
            self.object = object
        self.object_nsprefix_ = None
        if deftype is None:
            self.deftype = []
        else:
            self.deftype = deftype
        self.deftype_nsprefix_ = None
        if includes is None:
            self.includes = []
        else:
            self.includes = includes
        self.includes_nsprefix_ = None
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, blocks_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if blocks_T.subclass:
            return blocks_T.subclass(*args_, **kwargs_)
        else:
            return blocks_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def add_file(self, value):
        self.file.append(value)
    def insert_file_at(self, index, value):
        self.file.insert(index, value)
    def replace_file_at(self, index, value):
        self.file[index] = value
    def get_shim_params(self):
        return self.shim_params
    def set_shim_params(self, shim_params):
        self.shim_params = shim_params
    def add_shim_params(self, value):
        self.shim_params.append(value)
    def insert_shim_params_at(self, index, value):
        self.shim_params.insert(index, value)
    def replace_shim_params_at(self, index, value):
        self.shim_params[index] = value
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def add_block(self, value):
        self.block.append(value)
    def insert_block_at(self, index, value):
        self.block.insert(index, value)
    def replace_block_at(self, index, value):
        self.block[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def add_code(self, value):
        self.code.append(value)
    def insert_code_at(self, index, value):
        self.code.insert(index, value)
    def replace_code_at(self, index, value):
        self.code[index] = value
    def get_object(self):
        return self.object
    def set_object(self, object):
        self.object = object
    def add_object(self, value):
        self.object.append(value)
    def insert_object_at(self, index, value):
        self.object.insert(index, value)
    def replace_object_at(self, index, value):
        self.object[index] = value
    def get_deftype(self):
        return self.deftype
    def set_deftype(self, deftype):
        self.deftype = deftype
    def add_deftype(self, value):
        self.deftype.append(value)
    def insert_deftype_at(self, index, value):
        self.deftype.insert(index, value)
    def replace_deftype_at(self, index, value):
        self.deftype[index] = value
    def get_includes(self):
        return self.includes
    def set_includes(self, includes):
        self.includes = includes
    def add_includes(self, value):
        self.includes.append(value)
    def insert_includes_at(self, index, value):
        self.includes.insert(index, value)
    def replace_includes_at(self, index, value):
        self.includes[index] = value
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.file or
            self.shim_params or
            self.block or
            self.code or
            self.object or
            self.deftype or
            self.includes or
            self.function
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='blocks_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('blocks_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'blocks_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='blocks_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='blocks_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='blocks_T'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='blocks_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for file_ in self.file:
            namespaceprefix_ = self.file_nsprefix_ + ':' if (UseCapturedNS_ and self.file_nsprefix_) else ''
            file_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='file', pretty_print=pretty_print)
        for shim_params_ in self.shim_params:
            namespaceprefix_ = self.shim_params_nsprefix_ + ':' if (UseCapturedNS_ and self.shim_params_nsprefix_) else ''
            shim_params_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shim-params', pretty_print=pretty_print)
        for block_ in self.block:
            namespaceprefix_ = self.block_nsprefix_ + ':' if (UseCapturedNS_ and self.block_nsprefix_) else ''
            block_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='block', pretty_print=pretty_print)
        for code_ in self.code:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            code_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for object_ in self.object:
            namespaceprefix_ = self.object_nsprefix_ + ':' if (UseCapturedNS_ and self.object_nsprefix_) else ''
            object_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object', pretty_print=pretty_print)
        for deftype_ in self.deftype:
            namespaceprefix_ = self.deftype_nsprefix_ + ':' if (UseCapturedNS_ and self.deftype_nsprefix_) else ''
            deftype_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deftype', pretty_print=pretty_print)
        for includes_ in self.includes:
            namespaceprefix_ = self.includes_nsprefix_ + ':' if (UseCapturedNS_ and self.includes_nsprefix_) else ''
            includes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='includes', pretty_print=pretty_print)
        for function_ in self.function:
            namespaceprefix_ = self.function_nsprefix_ + ':' if (UseCapturedNS_ and self.function_nsprefix_) else ''
            function_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='function', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'file':
            obj_ = file_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'shim-params':
            obj_ = shim_params_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shim_params.append(obj_)
            obj_.original_tagname_ = 'shim-params'
        elif nodeName_ == 'block':
            obj_ = block_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block.append(obj_)
            obj_.original_tagname_ = 'block'
        elif nodeName_ == 'code':
            obj_ = code_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code.append(obj_)
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'object':
            obj_ = object_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'deftype':
            obj_ = object_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deftype.append(obj_)
            obj_.original_tagname_ = 'deftype'
        elif nodeName_ == 'includes':
            obj_ = include_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.includes.append(obj_)
            obj_.original_tagname_ = 'includes'
        elif nodeName_ == 'function':
            obj_ = function_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
# end class blocks_T


class file_T(GeneratedsSuper):
    """Input File Information"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, timestamp=None, size=None, map=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.timestamp = _cast(None, timestamp)
        self.timestamp_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        if map is None:
            self.map = []
        else:
            self.map = map
        self.map_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, file_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if file_T.subclass:
            return file_T.subclass(*args_, **kwargs_)
        else:
            return file_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_map(self):
        return self.map
    def set_map(self, map):
        self.map = map
    def add_map(self, value):
        self.map.append(value)
    def insert_map_at(self, index, value):
        self.map.insert(index, value)
    def replace_map_at(self, index, value):
        self.map[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['shim', 'shim-schema', 'c-source', 'c-header', 'c-data', 'xml', 'amalthea', 'clang-ast', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.map
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='file_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('file_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'file_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='file_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='file_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='file_T'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.timestamp), input_name='timestamp')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='file_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for map_ in self.map:
            namespaceprefix_ = self.map_nsprefix_ + ':' if (UseCapturedNS_ and self.map_nsprefix_) else ''
            map_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='map', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            self.timestamp = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'map':
            obj_ = map_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.map.append(obj_)
            obj_.original_tagname_ = 'map'
# end class file_T


class shim_params_T(GeneratedsSuper):
    """SHIM Parameters"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, element=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.element = _cast(None, element)
        self.element_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, shim_params_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if shim_params_T.subclass:
            return shim_params_T.subclass(*args_, **kwargs_)
        else:
            return shim_params_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_elementType(self, value):
        # Validate type elementType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['componentset', 'mastercomponent', 'commoninstructionset']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on elementType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='shim_params_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('shim_params_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'shim_params_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='shim_params_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='shim_params_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='shim_params_T'):
        if self.element is not None and 'element' not in already_processed:
            already_processed.add('element')
            outfile.write(' element=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.element), input_name='element')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='shim_params_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.add('element')
            self.element = value
            self.validate_elementType(self.element)    # validate type elementType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class shim_params_T


class block_T(GeneratedsSuper):
    """Block Information"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, blocktype=None, name=None, type_=None, rate=None, Period=None, PulseType=None, PulseWidth=None, peinfo=None, id=None, priority=None, sequence=None, stateflow=None, DataStoreName=None, TreatAsAtomicUnit=None, SampleTimeType=None, TriggerType=None, TriggerSignalSampleTime=None, measuringResult=None, forced=None, input=None, output=None, blocks=None, var=None, signal=None, state=None, trigger_state=None, invariant_signal=None, param=None, const_param=None, generic=None, code=None, performance=None, forward=None, backward=None, merged_to=None, merge_block=None, bind=None, bound_to=None, function=None, map=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.blocktype = _cast(None, blocktype)
        self.blocktype_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
        self.Period = _cast(None, Period)
        self.Period_nsprefix_ = None
        self.PulseType = _cast(None, PulseType)
        self.PulseType_nsprefix_ = None
        self.PulseWidth = _cast(float, PulseWidth)
        self.PulseWidth_nsprefix_ = None
        self.peinfo = _cast(None, peinfo)
        self.peinfo_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.priority = _cast(int, priority)
        self.priority_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.stateflow = _cast(None, stateflow)
        self.stateflow_nsprefix_ = None
        self.DataStoreName = _cast(None, DataStoreName)
        self.DataStoreName_nsprefix_ = None
        self.TreatAsAtomicUnit = _cast(None, TreatAsAtomicUnit)
        self.TreatAsAtomicUnit_nsprefix_ = None
        self.SampleTimeType = _cast(None, SampleTimeType)
        self.SampleTimeType_nsprefix_ = None
        self.TriggerType = _cast(None, TriggerType)
        self.TriggerType_nsprefix_ = None
        self.TriggerSignalSampleTime = _cast(None, TriggerSignalSampleTime)
        self.TriggerSignalSampleTime_nsprefix_ = None
        self.measuringResult = _cast(int, measuringResult)
        self.measuringResult_nsprefix_ = None
        self.forced = _cast(None, forced)
        self.forced_nsprefix_ = None
        if input is None:
            self.input = []
        else:
            self.input = input
        self.input_nsprefix_ = None
        if output is None:
            self.output = []
        else:
            self.output = output
        self.output_nsprefix_ = None
        if blocks is None:
            self.blocks = []
        else:
            self.blocks = blocks
        self.blocks_nsprefix_ = None
        if var is None:
            self.var = []
        else:
            self.var = var
        self.var_nsprefix_ = None
        if signal is None:
            self.signal = []
        else:
            self.signal = signal
        self.signal_nsprefix_ = None
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = None
        if trigger_state is None:
            self.trigger_state = []
        else:
            self.trigger_state = trigger_state
        self.trigger_state_nsprefix_ = None
        if invariant_signal is None:
            self.invariant_signal = []
        else:
            self.invariant_signal = invariant_signal
        self.invariant_signal_nsprefix_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
        self.param_nsprefix_ = None
        if const_param is None:
            self.const_param = []
        else:
            self.const_param = const_param
        self.const_param_nsprefix_ = None
        if generic is None:
            self.generic = []
        else:
            self.generic = generic
        self.generic_nsprefix_ = None
        if code is None:
            self.code = []
        else:
            self.code = code
        self.code_nsprefix_ = None
        if performance is None:
            self.performance = []
        else:
            self.performance = performance
        self.performance_nsprefix_ = None
        if forward is None:
            self.forward = []
        else:
            self.forward = forward
        self.forward_nsprefix_ = None
        if backward is None:
            self.backward = []
        else:
            self.backward = backward
        self.backward_nsprefix_ = None
        if merged_to is None:
            self.merged_to = []
        else:
            self.merged_to = merged_to
        self.merged_to_nsprefix_ = None
        if merge_block is None:
            self.merge_block = []
        else:
            self.merge_block = merge_block
        self.merge_block_nsprefix_ = None
        if bind is None:
            self.bind = []
        else:
            self.bind = bind
        self.bind_nsprefix_ = None
        if bound_to is None:
            self.bound_to = []
        else:
            self.bound_to = bound_to
        self.bound_to_nsprefix_ = None
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = None
        if map is None:
            self.map = []
        else:
            self.map = map
        self.map_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, block_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if block_T.subclass:
            return block_T.subclass(*args_, **kwargs_)
        else:
            return block_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_input(self):
        return self.input
    def set_input(self, input):
        self.input = input
    def add_input(self, value):
        self.input.append(value)
    def insert_input_at(self, index, value):
        self.input.insert(index, value)
    def replace_input_at(self, index, value):
        self.input[index] = value
    def get_output(self):
        return self.output
    def set_output(self, output):
        self.output = output
    def add_output(self, value):
        self.output.append(value)
    def insert_output_at(self, index, value):
        self.output.insert(index, value)
    def replace_output_at(self, index, value):
        self.output[index] = value
    def get_blocks(self):
        return self.blocks
    def set_blocks(self, blocks):
        self.blocks = blocks
    def add_blocks(self, value):
        self.blocks.append(value)
    def insert_blocks_at(self, index, value):
        self.blocks.insert(index, value)
    def replace_blocks_at(self, index, value):
        self.blocks[index] = value
    def get_var(self):
        return self.var
    def set_var(self, var):
        self.var = var
    def add_var(self, value):
        self.var.append(value)
    def insert_var_at(self, index, value):
        self.var.insert(index, value)
    def replace_var_at(self, index, value):
        self.var[index] = value
    def get_signal(self):
        return self.signal
    def set_signal(self, signal):
        self.signal = signal
    def add_signal(self, value):
        self.signal.append(value)
    def insert_signal_at(self, index, value):
        self.signal.insert(index, value)
    def replace_signal_at(self, index, value):
        self.signal[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def get_trigger_state(self):
        return self.trigger_state
    def set_trigger_state(self, trigger_state):
        self.trigger_state = trigger_state
    def add_trigger_state(self, value):
        self.trigger_state.append(value)
    def insert_trigger_state_at(self, index, value):
        self.trigger_state.insert(index, value)
    def replace_trigger_state_at(self, index, value):
        self.trigger_state[index] = value
    def get_invariant_signal(self):
        return self.invariant_signal
    def set_invariant_signal(self, invariant_signal):
        self.invariant_signal = invariant_signal
    def add_invariant_signal(self, value):
        self.invariant_signal.append(value)
    def insert_invariant_signal_at(self, index, value):
        self.invariant_signal.insert(index, value)
    def replace_invariant_signal_at(self, index, value):
        self.invariant_signal[index] = value
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param_at(self, index, value):
        self.param.insert(index, value)
    def replace_param_at(self, index, value):
        self.param[index] = value
    def get_const_param(self):
        return self.const_param
    def set_const_param(self, const_param):
        self.const_param = const_param
    def add_const_param(self, value):
        self.const_param.append(value)
    def insert_const_param_at(self, index, value):
        self.const_param.insert(index, value)
    def replace_const_param_at(self, index, value):
        self.const_param[index] = value
    def get_generic(self):
        return self.generic
    def set_generic(self, generic):
        self.generic = generic
    def add_generic(self, value):
        self.generic.append(value)
    def insert_generic_at(self, index, value):
        self.generic.insert(index, value)
    def replace_generic_at(self, index, value):
        self.generic[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def add_code(self, value):
        self.code.append(value)
    def insert_code_at(self, index, value):
        self.code.insert(index, value)
    def replace_code_at(self, index, value):
        self.code[index] = value
    def get_performance(self):
        return self.performance
    def set_performance(self, performance):
        self.performance = performance
    def add_performance(self, value):
        self.performance.append(value)
    def insert_performance_at(self, index, value):
        self.performance.insert(index, value)
    def replace_performance_at(self, index, value):
        self.performance[index] = value
    def get_forward(self):
        return self.forward
    def set_forward(self, forward):
        self.forward = forward
    def add_forward(self, value):
        self.forward.append(value)
    def insert_forward_at(self, index, value):
        self.forward.insert(index, value)
    def replace_forward_at(self, index, value):
        self.forward[index] = value
    def get_backward(self):
        return self.backward
    def set_backward(self, backward):
        self.backward = backward
    def add_backward(self, value):
        self.backward.append(value)
    def insert_backward_at(self, index, value):
        self.backward.insert(index, value)
    def replace_backward_at(self, index, value):
        self.backward[index] = value
    def get_merged_to(self):
        return self.merged_to
    def set_merged_to(self, merged_to):
        self.merged_to = merged_to
    def add_merged_to(self, value):
        self.merged_to.append(value)
    def insert_merged_to_at(self, index, value):
        self.merged_to.insert(index, value)
    def replace_merged_to_at(self, index, value):
        self.merged_to[index] = value
    def get_merge_block(self):
        return self.merge_block
    def set_merge_block(self, merge_block):
        self.merge_block = merge_block
    def add_merge_block(self, value):
        self.merge_block.append(value)
    def insert_merge_block_at(self, index, value):
        self.merge_block.insert(index, value)
    def replace_merge_block_at(self, index, value):
        self.merge_block[index] = value
    def get_bind(self):
        return self.bind
    def set_bind(self, bind):
        self.bind = bind
    def add_bind(self, value):
        self.bind.append(value)
    def insert_bind_at(self, index, value):
        self.bind.insert(index, value)
    def replace_bind_at(self, index, value):
        self.bind[index] = value
    def get_bound_to(self):
        return self.bound_to
    def set_bound_to(self, bound_to):
        self.bound_to = bound_to
    def add_bound_to(self, value):
        self.bound_to.append(value)
    def insert_bound_to_at(self, index, value):
        self.bound_to.insert(index, value)
    def replace_bound_to_at(self, index, value):
        self.bound_to[index] = value
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_map(self):
        return self.map
    def set_map(self, map):
        self.map = map
    def add_map(self, value):
        self.map.append(value)
    def insert_map_at(self, index, value):
        self.map.insert(index, value)
    def replace_map_at(self, index, value):
        self.map[index] = value
    def get_blocktype(self):
        return self.blocktype
    def set_blocktype(self, blocktype):
        self.blocktype = blocktype
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_rate(self):
        return self.rate
    def set_rate(self, rate):
        self.rate = rate
    def get_Period(self):
        return self.Period
    def set_Period(self, Period):
        self.Period = Period
    def get_PulseType(self):
        return self.PulseType
    def set_PulseType(self, PulseType):
        self.PulseType = PulseType
    def get_PulseWidth(self):
        return self.PulseWidth
    def set_PulseWidth(self, PulseWidth):
        self.PulseWidth = PulseWidth
    def get_peinfo(self):
        return self.peinfo
    def set_peinfo(self, peinfo):
        self.peinfo = peinfo
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_stateflow(self):
        return self.stateflow
    def set_stateflow(self, stateflow):
        self.stateflow = stateflow
    def get_DataStoreName(self):
        return self.DataStoreName
    def set_DataStoreName(self, DataStoreName):
        self.DataStoreName = DataStoreName
    def get_TreatAsAtomicUnit(self):
        return self.TreatAsAtomicUnit
    def set_TreatAsAtomicUnit(self, TreatAsAtomicUnit):
        self.TreatAsAtomicUnit = TreatAsAtomicUnit
    def get_SampleTimeType(self):
        return self.SampleTimeType
    def set_SampleTimeType(self, SampleTimeType):
        self.SampleTimeType = SampleTimeType
    def get_TriggerType(self):
        return self.TriggerType
    def set_TriggerType(self, TriggerType):
        self.TriggerType = TriggerType
    def get_TriggerSignalSampleTime(self):
        return self.TriggerSignalSampleTime
    def set_TriggerSignalSampleTime(self, TriggerSignalSampleTime):
        self.TriggerSignalSampleTime = TriggerSignalSampleTime
    def get_measuringResult(self):
        return self.measuringResult
    def set_measuringResult(self, measuringResult):
        self.measuringResult = measuringResult
    def get_forced(self):
        return self.forced
    def set_forced(self, forced):
        self.forced = forced
    def hasContent_(self):
        if (
            self.input or
            self.output or
            self.blocks or
            self.var or
            self.signal or
            self.state or
            self.trigger_state or
            self.invariant_signal or
            self.param or
            self.const_param or
            self.generic or
            self.code or
            self.performance or
            self.forward or
            self.backward or
            self.merged_to or
            self.merge_block or
            self.bind or
            self.bound_to or
            self.function or
            self.map
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='block_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('block_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'block_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='block_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='block_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='block_T'):
        if self.blocktype is not None and 'blocktype' not in already_processed:
            already_processed.add('blocktype')
            outfile.write(' blocktype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.blocktype), input_name='blocktype')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rate), input_name='rate')), ))
        if self.Period is not None and 'Period' not in already_processed:
            already_processed.add('Period')
            outfile.write(' Period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Period), input_name='Period')), ))
        if self.PulseType is not None and 'PulseType' not in already_processed:
            already_processed.add('PulseType')
            outfile.write(' PulseType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PulseType), input_name='PulseType')), ))
        if self.PulseWidth is not None and 'PulseWidth' not in already_processed:
            already_processed.add('PulseWidth')
            outfile.write(' PulseWidth="%s"' % self.gds_format_float(self.PulseWidth, input_name='PulseWidth'))
        if self.peinfo is not None and 'peinfo' not in already_processed:
            already_processed.add('peinfo')
            outfile.write(' peinfo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.peinfo), input_name='peinfo')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.stateflow is not None and 'stateflow' not in already_processed:
            already_processed.add('stateflow')
            outfile.write(' stateflow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.stateflow), input_name='stateflow')), ))
        if self.DataStoreName is not None and 'DataStoreName' not in already_processed:
            already_processed.add('DataStoreName')
            outfile.write(' DataStoreName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DataStoreName), input_name='DataStoreName')), ))
        if self.TreatAsAtomicUnit is not None and 'TreatAsAtomicUnit' not in already_processed:
            already_processed.add('TreatAsAtomicUnit')
            outfile.write(' TreatAsAtomicUnit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TreatAsAtomicUnit), input_name='TreatAsAtomicUnit')), ))
        if self.SampleTimeType is not None and 'SampleTimeType' not in already_processed:
            already_processed.add('SampleTimeType')
            outfile.write(' SampleTimeType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SampleTimeType), input_name='SampleTimeType')), ))
        if self.TriggerType is not None and 'TriggerType' not in already_processed:
            already_processed.add('TriggerType')
            outfile.write(' TriggerType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TriggerType), input_name='TriggerType')), ))
        if self.TriggerSignalSampleTime is not None and 'TriggerSignalSampleTime' not in already_processed:
            already_processed.add('TriggerSignalSampleTime')
            outfile.write(' TriggerSignalSampleTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TriggerSignalSampleTime), input_name='TriggerSignalSampleTime')), ))
        if self.measuringResult is not None and 'measuringResult' not in already_processed:
            already_processed.add('measuringResult')
            outfile.write(' measuringResult="%s"' % self.gds_format_integer(self.measuringResult, input_name='measuringResult'))
        if self.forced is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            outfile.write(' forced=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.forced), input_name='forced')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='block_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for input_ in self.input:
            namespaceprefix_ = self.input_nsprefix_ + ':' if (UseCapturedNS_ and self.input_nsprefix_) else ''
            input_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='input', pretty_print=pretty_print)
        for output_ in self.output:
            namespaceprefix_ = self.output_nsprefix_ + ':' if (UseCapturedNS_ and self.output_nsprefix_) else ''
            output_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='output', pretty_print=pretty_print)
        for blocks_ in self.blocks:
            namespaceprefix_ = self.blocks_nsprefix_ + ':' if (UseCapturedNS_ and self.blocks_nsprefix_) else ''
            blocks_.export(outfile, level, namespaceprefix_='sns:', namespacedef_='', name_='blocks', pretty_print=pretty_print)
        for var_ in self.var:
            namespaceprefix_ = self.var_nsprefix_ + ':' if (UseCapturedNS_ and self.var_nsprefix_) else ''
            var_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='var', pretty_print=pretty_print)
        for signal_ in self.signal:
            namespaceprefix_ = self.signal_nsprefix_ + ':' if (UseCapturedNS_ and self.signal_nsprefix_) else ''
            signal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signal', pretty_print=pretty_print)
        for state_ in self.state:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        for trigger_state_ in self.trigger_state:
            namespaceprefix_ = self.trigger_state_nsprefix_ + ':' if (UseCapturedNS_ and self.trigger_state_nsprefix_) else ''
            trigger_state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trigger_state', pretty_print=pretty_print)
        for invariant_signal_ in self.invariant_signal:
            namespaceprefix_ = self.invariant_signal_nsprefix_ + ':' if (UseCapturedNS_ and self.invariant_signal_nsprefix_) else ''
            invariant_signal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invariant_signal', pretty_print=pretty_print)
        for param_ in self.param:
            namespaceprefix_ = self.param_nsprefix_ + ':' if (UseCapturedNS_ and self.param_nsprefix_) else ''
            param_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='param', pretty_print=pretty_print)
        for const_param_ in self.const_param:
            namespaceprefix_ = self.const_param_nsprefix_ + ':' if (UseCapturedNS_ and self.const_param_nsprefix_) else ''
            const_param_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='const_param', pretty_print=pretty_print)
        for generic_ in self.generic:
            namespaceprefix_ = self.generic_nsprefix_ + ':' if (UseCapturedNS_ and self.generic_nsprefix_) else ''
            generic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generic', pretty_print=pretty_print)
        for code_ in self.code:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            code_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for performance_ in self.performance:
            namespaceprefix_ = self.performance_nsprefix_ + ':' if (UseCapturedNS_ and self.performance_nsprefix_) else ''
            performance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performance', pretty_print=pretty_print)
        for forward_ in self.forward:
            namespaceprefix_ = self.forward_nsprefix_ + ':' if (UseCapturedNS_ and self.forward_nsprefix_) else ''
            forward_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forward', pretty_print=pretty_print)
        for backward_ in self.backward:
            namespaceprefix_ = self.backward_nsprefix_ + ':' if (UseCapturedNS_ and self.backward_nsprefix_) else ''
            backward_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='backward', pretty_print=pretty_print)
        for merged_to_ in self.merged_to:
            namespaceprefix_ = self.merged_to_nsprefix_ + ':' if (UseCapturedNS_ and self.merged_to_nsprefix_) else ''
            merged_to_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='merged_to', pretty_print=pretty_print)
        for merge_block_ in self.merge_block:
            namespaceprefix_ = self.merge_block_nsprefix_ + ':' if (UseCapturedNS_ and self.merge_block_nsprefix_) else ''
            merge_block_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='merge_block', pretty_print=pretty_print)
        for bind_ in self.bind:
            namespaceprefix_ = self.bind_nsprefix_ + ':' if (UseCapturedNS_ and self.bind_nsprefix_) else ''
            bind_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bind', pretty_print=pretty_print)
        for bound_to_ in self.bound_to:
            namespaceprefix_ = self.bound_to_nsprefix_ + ':' if (UseCapturedNS_ and self.bound_to_nsprefix_) else ''
            bound_to_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bound_to', pretty_print=pretty_print)
        for function_ in self.function:
            namespaceprefix_ = self.function_nsprefix_ + ':' if (UseCapturedNS_ and self.function_nsprefix_) else ''
            function_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='function', pretty_print=pretty_print)
        for map_ in self.map:
            namespaceprefix_ = self.map_nsprefix_ + ':' if (UseCapturedNS_ and self.map_nsprefix_) else ''
            map_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='map', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('blocktype', node)
        if value is not None and 'blocktype' not in already_processed:
            already_processed.add('blocktype')
            self.blocktype = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            self.rate = value
        value = find_attr_value_('Period', node)
        if value is not None and 'Period' not in already_processed:
            already_processed.add('Period')
            self.Period = value
        value = find_attr_value_('PulseType', node)
        if value is not None and 'PulseType' not in already_processed:
            already_processed.add('PulseType')
            self.PulseType = value
        value = find_attr_value_('PulseWidth', node)
        if value is not None and 'PulseWidth' not in already_processed:
            already_processed.add('PulseWidth')
            value = self.gds_parse_float(value, node, 'PulseWidth')
            self.PulseWidth = value
        value = find_attr_value_('peinfo', node)
        if value is not None and 'peinfo' not in already_processed:
            already_processed.add('peinfo')
            self.peinfo = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            self.priority = self.gds_parse_integer(value, node, 'priority')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('stateflow', node)
        if value is not None and 'stateflow' not in already_processed:
            already_processed.add('stateflow')
            self.stateflow = value
        value = find_attr_value_('DataStoreName', node)
        if value is not None and 'DataStoreName' not in already_processed:
            already_processed.add('DataStoreName')
            self.DataStoreName = value
        value = find_attr_value_('TreatAsAtomicUnit', node)
        if value is not None and 'TreatAsAtomicUnit' not in already_processed:
            already_processed.add('TreatAsAtomicUnit')
            self.TreatAsAtomicUnit = value
        value = find_attr_value_('SampleTimeType', node)
        if value is not None and 'SampleTimeType' not in already_processed:
            already_processed.add('SampleTimeType')
            self.SampleTimeType = value
        value = find_attr_value_('TriggerType', node)
        if value is not None and 'TriggerType' not in already_processed:
            already_processed.add('TriggerType')
            self.TriggerType = value
        value = find_attr_value_('TriggerSignalSampleTime', node)
        if value is not None and 'TriggerSignalSampleTime' not in already_processed:
            already_processed.add('TriggerSignalSampleTime')
            self.TriggerSignalSampleTime = value
        value = find_attr_value_('measuringResult', node)
        if value is not None and 'measuringResult' not in already_processed:
            already_processed.add('measuringResult')
            self.measuringResult = self.gds_parse_integer(value, node, 'measuringResult')
        value = find_attr_value_('forced', node)
        if value is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            self.forced = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'input':
            obj_ = ioport_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.input.append(obj_)
            obj_.original_tagname_ = 'input'
        elif nodeName_ == 'output':
            obj_ = ioport_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.output.append(obj_)
            obj_.original_tagname_ = 'output'
        elif nodeName_ == 'blocks':
            obj_ = blocks_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blocks.append(obj_)
            obj_.original_tagname_ = 'blocks'
        elif nodeName_ == 'var':
            obj_ = var_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.var.append(obj_)
            obj_.original_tagname_ = 'var'
        elif nodeName_ == 'signal':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signal.append(obj_)
            obj_.original_tagname_ = 'signal'
        elif nodeName_ == 'state':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state.append(obj_)
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'trigger_state':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trigger_state.append(obj_)
            obj_.original_tagname_ = 'trigger_state'
        elif nodeName_ == 'invariant_signal':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invariant_signal.append(obj_)
            obj_.original_tagname_ = 'invariant_signal'
        elif nodeName_ == 'param':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
        elif nodeName_ == 'const_param':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.const_param.append(obj_)
            obj_.original_tagname_ = 'const_param'
        elif nodeName_ == 'generic':
            obj_ = param_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generic.append(obj_)
            obj_.original_tagname_ = 'generic'
        elif nodeName_ == 'code':
            obj_ = code_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code.append(obj_)
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'performance':
            obj_ = performance_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performance.append(obj_)
            obj_.original_tagname_ = 'performance'
        elif nodeName_ == 'forward':
            obj_ = link_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward.append(obj_)
            obj_.original_tagname_ = 'forward'
        elif nodeName_ == 'backward':
            obj_ = link_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.backward.append(obj_)
            obj_.original_tagname_ = 'backward'
        elif nodeName_ == 'merged_to':
            obj_ = block_name_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.merged_to.append(obj_)
            obj_.original_tagname_ = 'merged_to'
        elif nodeName_ == 'merge_block':
            obj_ = block_name_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.merge_block.append(obj_)
            obj_.original_tagname_ = 'merge_block'
        elif nodeName_ == 'bind':
            obj_ = block_name_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bind.append(obj_)
            obj_.original_tagname_ = 'bind'
        elif nodeName_ == 'bound_to':
            obj_ = block_name_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bound_to.append(obj_)
            obj_.original_tagname_ = 'bound_to'
        elif nodeName_ == 'function':
            obj_ = function_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'map':
            obj_ = map_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.map.append(obj_)
            obj_.original_tagname_ = 'map'
# end class block_T


class ioport_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, line=None, port=None, type_=None, usename=None, dimensions=None, selectedsignal=None, connect=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.line = _cast(None, line)
        self.line_nsprefix_ = None
        self.port = _cast(None, port)
        self.port_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.usename = _cast(bool, usename)
        self.usename_nsprefix_ = None
        self.dimensions = _cast(None, dimensions)
        self.dimensions_nsprefix_ = None
        self.selectedsignal = _cast(None, selectedsignal)
        self.selectedsignal_nsprefix_ = None
        if connect is None:
            self.connect = []
        else:
            self.connect = connect
        self.connect_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ioport_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ioport_T.subclass:
            return ioport_T.subclass(*args_, **kwargs_)
        else:
            return ioport_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_connect(self):
        return self.connect
    def set_connect(self, connect):
        self.connect = connect
    def add_connect(self, value):
        self.connect.append(value)
    def insert_connect_at(self, index, value):
        self.connect.insert(index, value)
    def replace_connect_at(self, index, value):
        self.connect[index] = value
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_usename(self):
        return self.usename
    def set_usename(self, usename):
        self.usename = usename
    def get_dimensions(self):
        return self.dimensions
    def set_dimensions(self, dimensions):
        self.dimensions = dimensions
    def get_selectedsignal(self):
        return self.selectedsignal
    def set_selectedsignal(self, selectedsignal):
        self.selectedsignal = selectedsignal
    def hasContent_(self):
        if (
            self.connect
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='ioport_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ioport_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ioport_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ioport_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ioport_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ioport_T'):
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line), input_name='line')), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.port), input_name='port')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.usename is not None and 'usename' not in already_processed:
            already_processed.add('usename')
            outfile.write(' usename="%s"' % self.gds_format_boolean(self.usename, input_name='usename'))
        if self.dimensions is not None and 'dimensions' not in already_processed:
            already_processed.add('dimensions')
            outfile.write(' dimensions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dimensions), input_name='dimensions')), ))
        if self.selectedsignal is not None and 'selectedsignal' not in already_processed:
            already_processed.add('selectedsignal')
            outfile.write(' selectedsignal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.selectedsignal), input_name='selectedsignal')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='ioport_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connect_ in self.connect:
            namespaceprefix_ = self.connect_nsprefix_ + ':' if (UseCapturedNS_ and self.connect_nsprefix_) else ''
            connect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connect', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            self.port = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('usename', node)
        if value is not None and 'usename' not in already_processed:
            already_processed.add('usename')
            if value in ('true', '1'):
                self.usename = True
            elif value in ('false', '0'):
                self.usename = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dimensions', node)
        if value is not None and 'dimensions' not in already_processed:
            already_processed.add('dimensions')
            self.dimensions = value
        value = find_attr_value_('selectedsignal', node)
        if value is not None and 'selectedsignal' not in already_processed:
            already_processed.add('selectedsignal')
            self.selectedsignal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'connect':
            obj_ = connection_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connect.append(obj_)
            obj_.original_tagname_ = 'connect'
# end class ioport_T


class connection_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, block=None, port=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.block = _cast(None, block)
        self.block_nsprefix_ = None
        self.port = _cast(None, port)
        self.port_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, connection_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if connection_T.subclass:
            return connection_T.subclass(*args_, **kwargs_)
        else:
            return connection_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='connection_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('connection_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'connection_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='connection_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='connection_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='connection_T'):
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.block), input_name='block')), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.port), input_name='port')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='connection_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            self.port = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class connection_T


class var_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, storage=None, name=None, type_=None, mode=None, line=None, port=None, size=None, start=None, end=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.storage = _cast(None, storage)
        self.storage_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.line = _cast(None, line)
        self.line_nsprefix_ = None
        self.port = _cast(None, port)
        self.port_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.start = _cast(int, start)
        self.start_nsprefix_ = None
        self.end = _cast(int, end)
        self.end_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, var_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if var_T.subclass:
            return var_T.subclass(*args_, **kwargs_)
        else:
            return var_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_storage(self):
        return self.storage
    def set_storage(self, storage):
        self.storage = storage
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_start(self):
        return self.start
    def set_start(self, start):
        self.start = start
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def validate_modeType(self, value):
        # Validate type modeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['extin', 'extout', 'input', 'output', 'state', 'trigger_state', 'invariant_signal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='var_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('var_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'var_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='var_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='var_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='var_T'):
        if self.storage is not None and 'storage' not in already_processed:
            already_processed.add('storage')
            outfile.write(' storage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.storage), input_name='storage')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line), input_name='line')), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.port), input_name='port')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start="%s"' % self.gds_format_integer(self.start, input_name='start'))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end="%s"' % self.gds_format_integer(self.end, input_name='end'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='var_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('storage', node)
        if value is not None and 'storage' not in already_processed:
            already_processed.add('storage')
            self.storage = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_modeType(self.mode)    # validate type modeType
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            self.port = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = self.gds_parse_integer(value, node, 'start')
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = self.gds_parse_integer(value, node, 'end')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class var_T


class param_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, storage=None, name=None, type_=None, size=None, value=None, initcode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.storage = _cast(None, storage)
        self.storage_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.initcode = initcode
        self.initcode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, param_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if param_T.subclass:
            return param_T.subclass(*args_, **kwargs_)
        else:
            return param_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_initcode(self):
        return self.initcode
    def set_initcode(self, initcode):
        self.initcode = initcode
    def get_storage(self):
        return self.storage
    def set_storage(self, storage):
        self.storage = storage
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.initcode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='param_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('param_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'param_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='param_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='param_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='param_T'):
        if self.storage is not None and 'storage' not in already_processed:
            already_processed.add('storage')
            outfile.write(' storage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.storage), input_name='storage')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='param_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initcode is not None:
            namespaceprefix_ = self.initcode_nsprefix_ + ':' if (UseCapturedNS_ and self.initcode_nsprefix_) else ''
            self.initcode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initcode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('storage', node)
        if value is not None and 'storage' not in already_processed:
            already_processed.add('storage')
            self.storage = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'initcode':
            obj_ = code_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initcode = obj_
            obj_.original_tagname_ = 'initcode'
# end class param_T


class code_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, file=None, line=None, index=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.line = _cast(int, line)
        self.line_nsprefix_ = None
        self.index = _cast(int, index)
        self.index_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, code_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if code_T.subclass:
            return code_T.subclass(*args_, **kwargs_)
        else:
            return code_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType1(self, value):
        # Validate type typeType1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['task', 'update', 'init', 'state', 'invariant_signal', 'param', 'const', 'func', 'autovars', 'rt-macro', 'rt-type', 'rt-code', 'rt-init', 'common', 'common-init', 'c_macro', 'preamble']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='code_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('code_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'code_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='code_T')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='code_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='code_T'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line="%s"' % self.gds_format_integer(self.line, input_name='line'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='code_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType1(self.type_)    # validate type typeType1
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = self.gds_parse_integer(value, node, 'line')
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = self.gds_parse_integer(value, node, 'index')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class code_T


class performance_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, best=None, typical=None, worst=None, core_type=None, method=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.best = _cast(float, best)
        self.best_nsprefix_ = None
        self.typical = _cast(float, typical)
        self.typical_nsprefix_ = None
        self.worst = _cast(float, worst)
        self.worst_nsprefix_ = None
        self.core_type = _cast(None, core_type)
        self.core_type_nsprefix_ = None
        self.method = _cast(None, method)
        self.method_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, performance_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if performance_T.subclass:
            return performance_T.subclass(*args_, **kwargs_)
        else:
            return performance_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_best(self):
        return self.best
    def set_best(self, best):
        self.best = best
    def get_typical(self):
        return self.typical
    def set_typical(self, typical):
        self.typical = typical
    def get_worst(self):
        return self.worst
    def set_worst(self, worst):
        self.worst = worst
    def get_core_type(self):
        return self.core_type
    def set_core_type(self, core_type):
        self.core_type = core_type
    def get_method(self):
        return self.method
    def set_method(self, method):
        self.method = method
    def validate_typeType2(self, value):
        # Validate type typeType2, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['task', 'update', 'init']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='performance_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('performance_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'performance_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='performance_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='performance_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='performance_T'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.best is not None and 'best' not in already_processed:
            already_processed.add('best')
            outfile.write(' best="%s"' % self.gds_format_float(self.best, input_name='best'))
        if self.typical is not None and 'typical' not in already_processed:
            already_processed.add('typical')
            outfile.write(' typical="%s"' % self.gds_format_float(self.typical, input_name='typical'))
        if self.worst is not None and 'worst' not in already_processed:
            already_processed.add('worst')
            outfile.write(' worst="%s"' % self.gds_format_float(self.worst, input_name='worst'))
        if self.core_type is not None and 'core_type' not in already_processed:
            already_processed.add('core_type')
            outfile.write(' core_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.core_type), input_name='core_type')), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.add('method')
            outfile.write(' method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.method), input_name='method')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='performance_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType2(self.type_)    # validate type typeType2
        value = find_attr_value_('best', node)
        if value is not None and 'best' not in already_processed:
            already_processed.add('best')
            value = self.gds_parse_float(value, node, 'best')
            self.best = value
        value = find_attr_value_('typical', node)
        if value is not None and 'typical' not in already_processed:
            already_processed.add('typical')
            value = self.gds_parse_float(value, node, 'typical')
            self.typical = value
        value = find_attr_value_('worst', node)
        if value is not None and 'worst' not in already_processed:
            already_processed.add('worst')
            value = self.gds_parse_float(value, node, 'worst')
            self.worst = value
        value = find_attr_value_('core_type', node)
        if value is not None and 'core_type' not in already_processed:
            already_processed.add('core_type')
            self.core_type = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.add('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class performance_T


class link_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, block=None, type_=None, label=None, var=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.block = _cast(None, block)
        self.block_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        if var is None:
            self.var = []
        else:
            self.var = var
        self.var_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, link_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if link_T.subclass:
            return link_T.subclass(*args_, **kwargs_)
        else:
            return link_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_var(self):
        return self.var
    def set_var(self, var):
        self.var = var
    def add_var(self, value):
        self.var.append(value)
    def insert_var_at(self, index, value):
        self.var.insert(index, value)
    def replace_var_at(self, index, value):
        self.var[index] = value
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def validate_typeType3(self, value):
        # Validate type typeType3, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['data', 'event', 'port', 'init']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.var
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='link_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('link_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'link_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='link_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='link_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='link_T'):
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.block), input_name='block')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='link_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for var_ in self.var:
            namespaceprefix_ = self.var_nsprefix_ + ':' if (UseCapturedNS_ and self.var_nsprefix_) else ''
            var_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='var', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType3(self.type_)    # validate type typeType3
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'var':
            obj_ = var_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.var.append(obj_)
            obj_.original_tagname_ = 'var'
# end class link_T


class object_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, has_struct=None, name=None, size=None, value=None, kind=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.has_struct = _cast(bool, has_struct)
        self.has_struct_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, object_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if object_T.subclass:
            return object_T.subclass(*args_, **kwargs_)
        else:
            return object_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_has_struct(self):
        return self.has_struct
    def set_has_struct(self, has_struct):
        self.has_struct = has_struct
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_kindType(self, value):
        # Validate type kindType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rtm-extern', 'rtm-pointer', 'rtm-object', 'bsignal', 'bstate', 'param']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kindType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='object_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('object_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'object_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='object_T')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='object_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='object_T'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.has_struct is not None and 'has_struct' not in already_processed:
            already_processed.add('has_struct')
            outfile.write(' has_struct="%s"' % self.gds_format_boolean(self.has_struct, input_name='has_struct'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='object_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('has_struct', node)
        if value is not None and 'has_struct' not in already_processed:
            already_processed.add('has_struct')
            if value in ('true', '1'):
                self.has_struct = True
            elif value in ('false', '0'):
                self.has_struct = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_kindType(self.kind)    # validate type kindType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class object_T


class include_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, from_=None, file=None, mark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = _cast(int, index)
        self.index_nsprefix_ = None
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.mark = _cast(bool, mark)
        self.mark_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, include_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if include_T.subclass:
            return include_T.subclass(*args_, **kwargs_)
        else:
            return include_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_mark(self):
        return self.mark
    def set_mark(self, mark):
        self.mark = mark
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='include_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('include_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'include_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='include_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='include_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='include_T'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.mark is not None and 'mark' not in already_processed:
            already_processed.add('mark')
            outfile.write(' mark="%s"' % self.gds_format_boolean(self.mark, input_name='mark'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='include_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = self.gds_parse_integer(value, node, 'index')
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('mark', node)
        if value is not None and 'mark' not in already_processed:
            already_processed.add('mark')
            if value in ('true', '1'):
                self.mark = True
            elif value in ('false', '0'):
                self.mark = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class include_T


class function_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, kind=None, code=None, function=None, block=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = None
        if block is None:
            self.block = []
        else:
            self.block = block
        self.block_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, function_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if function_T.subclass:
            return function_T.subclass(*args_, **kwargs_)
        else:
            return function_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def add_block(self, value):
        self.block.append(value)
    def insert_block_at(self, index, value):
        self.block.insert(index, value)
    def replace_block_at(self, index, value):
        self.block[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def validate_typeType4(self, value):
        # Validate type typeType4, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['decl', 'defn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_kindType5(self, value):
        # Validate type kindType5, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['init', 'task', 'update']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kindType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.code is not None or
            self.function or
            self.block
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='function_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('function_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'function_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='function_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='function_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='function_T'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='function_T', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for function_ in self.function:
            namespaceprefix_ = self.function_nsprefix_ + ':' if (UseCapturedNS_ and self.function_nsprefix_) else ''
            function_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='function', pretty_print=pretty_print)
        for block_ in self.block:
            namespaceprefix_ = self.block_nsprefix_ + ':' if (UseCapturedNS_ and self.block_nsprefix_) else ''
            block_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='block', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType4(self.type_)    # validate type typeType4
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_kindType5(self.kind)    # validate type kindType5
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'code':
            obj_ = code_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'function':
            obj_ = function_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'block':
            obj_ = block_name_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block.append(obj_)
            obj_.original_tagname_ = 'block'
# end class function_T


class block_name_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, block=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.block = _cast(None, block)
        self.block_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, block_name_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if block_name_T.subclass:
            return block_name_T.subclass(*args_, **kwargs_)
        else:
            return block_name_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='block_name_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('block_name_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'block_name_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='block_name_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='block_name_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='block_name_T'):
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.block), input_name='block')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='block_name_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class block_name_T


class map_base_element_T(GeneratedsSuper):
    """User Map Base Element"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = _cast(int, index)
        self.index_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_base_element_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_base_element_T.subclass:
            return map_base_element_T.subclass(*args_, **kwargs_)
        else:
            return map_base_element_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_base_element_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_base_element_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_base_element_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_base_element_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_base_element_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_base_element_T'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_base_element_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = self.gds_parse_integer(value, node, 'index')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class map_base_element_T


class map_base_set_T(map_base_element_T):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = map_base_element_T
    def __init__(self, index=None, value=None, map=None, set=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(map_base_set_T, self).__init__(index, extensiontype_,  **kwargs_)
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        if map is None:
            self.map = []
        else:
            self.map = map
        self.map_nsprefix_ = None
        if set is None:
            self.set = []
        else:
            self.set = set
        self.set_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_base_set_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_base_set_T.subclass:
            return map_base_set_T.subclass(*args_, **kwargs_)
        else:
            return map_base_set_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_map(self):
        return self.map
    def set_map(self, map):
        self.map = map
    def add_map(self, value):
        self.map.append(value)
    def insert_map_at(self, index, value):
        self.map.insert(index, value)
    def replace_map_at(self, index, value):
        self.map[index] = value
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def add_set(self, value):
        self.set.append(value)
    def insert_set_at(self, index, value):
        self.set.insert(index, value)
    def replace_set_at(self, index, value):
        self.set[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.value or
            self.map or
            self.set or
            super(map_base_set_T, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_base_set_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_base_set_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_base_set_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_base_set_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_base_set_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_base_set_T'):
        super(map_base_set_T, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_base_set_T')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_base_set_T', fromsubclass_=False, pretty_print=True):
        super(map_base_set_T, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        for map_ in self.map:
            namespaceprefix_ = self.map_nsprefix_ + ':' if (UseCapturedNS_ and self.map_nsprefix_) else ''
            map_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='map', pretty_print=pretty_print)
        for set_ in self.set:
            namespaceprefix_ = self.set_nsprefix_ + ':' if (UseCapturedNS_ and self.set_nsprefix_) else ''
            set_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(map_base_set_T, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = map_value_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'map':
            obj_ = map_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.map.append(obj_)
            obj_.original_tagname_ = 'map'
        elif nodeName_ == 'set':
            obj_ = map_set_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set.append(obj_)
            obj_.original_tagname_ = 'set'
        super(map_base_set_T, self).buildChildren(child_, node, nodeName_, True)
# end class map_base_set_T


class map_T(map_base_element_T):
    """User Map Data"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = map_base_element_T
    def __init__(self, index=None, name=None, key=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(map_T, self).__init__(index,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if key is None:
            self.key = []
        else:
            self.key = key
        self.key_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_T.subclass:
            return map_T.subclass(*args_, **kwargs_)
        else:
            return map_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def add_key(self, value):
        self.key.append(value)
    def insert_key_at(self, index, value):
        self.key.insert(index, value)
    def replace_key_at(self, index, value):
        self.key[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.key or
            self.description is not None or
            super(map_T, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_T'):
        super(map_T, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_T')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_T', fromsubclass_=False, pretty_print=True):
        super(map_T, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for key_ in self.key:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            key_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(map_T, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'key':
            obj_ = map_key_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key.append(obj_)
            obj_.original_tagname_ = 'key'
        elif nodeName_ == 'description':
            obj_ = map_description_T.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        super(map_T, self).buildChildren(child_, node, nodeName_, True)
# end class map_T


class map_key_T(map_base_set_T):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = map_base_set_T
    def __init__(self, index=None, value=None, map=None, set=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(map_key_T, self).__init__(index, value, map, set,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_key_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_key_T.subclass:
            return map_key_T.subclass(*args_, **kwargs_)
        else:
            return map_key_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            super(map_key_T, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_key_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_key_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_key_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_key_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_key_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_key_T'):
        super(map_key_T, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_key_T')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_key_T', fromsubclass_=False, pretty_print=True):
        super(map_key_T, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(map_key_T, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(map_key_T, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class map_key_T


class map_set_T(map_base_set_T):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = map_base_set_T
    def __init__(self, index=None, value=None, map=None, set=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(map_set_T, self).__init__(index, value, map, set,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_set_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_set_T.subclass:
            return map_set_T.subclass(*args_, **kwargs_)
        else:
            return map_set_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            super(map_set_T, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_set_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_set_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_set_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_set_T')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_set_T', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_set_T'):
        super(map_set_T, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_set_T')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_set_T', fromsubclass_=False, pretty_print=True):
        super(map_set_T, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(map_set_T, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(map_set_T, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class map_set_T


class map_value_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = _cast(int, index)
        self.index_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_value_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_value_T.subclass:
            return map_value_T.subclass(*args_, **kwargs_)
        else:
            return map_value_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_value_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_value_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_value_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_value_T')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_value_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_value_T'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_value_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = self.gds_parse_integer(value, node, 'index')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class map_value_T


class map_description_T(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, map_description_T)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if map_description_T.subclass:
            return map_description_T.subclass(*args_, **kwargs_)
        else:
            return map_description_T(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_description_T', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('map_description_T')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'map_description_T':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='map_description_T')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='map_description_T', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='map_description_T'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:sns="http://example.com/SimulinkModel"', name_='map_description_T', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class map_description_T


GDSClassesMapping = {
    'blocks': blocks_T,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'blocks_T'
        rootClass = blocks_T
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'blocks_T'
        rootClass = blocks_T
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'blocks_T'
        rootClass = blocks_T
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:sns="http://example.com/SimulinkModel"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'blocks_T'
        rootClass = blocks_T
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from simulinkmodel import *\n\n')
        sys.stdout.write('import simulinkmodel as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "block_T",
    "block_name_T",
    "blocks_T",
    "code_T",
    "connection_T",
    "file_T",
    "function_T",
    "include_T",
    "ioport_T",
    "link_T",
    "map_T",
    "map_base_element_T",
    "map_base_set_T",
    "map_description_T",
    "map_key_T",
    "map_set_T",
    "map_value_T",
    "object_T",
    "param_T",
    "performance_T",
    "shim_params_T",
    "var_T"
]
